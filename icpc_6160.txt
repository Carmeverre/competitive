See my comments above the code and inline comments for further clarification.
The basic approach is to brute force a solution with a dfs variant.
The numbers are read into a list of remaining numbers, then recursively every pair is combined in each of the 4 operations available (subtraction and division are not commutative, but because only positive integers are allowed as operation results, they each have at most one legal option), then the combined result is replaced back with the 2 original numbers when the dfs comes back up. Whenever an operation result comes closer to the target than any previous, the sequence of operations is "saved". If one hits the target, the search stops and the result is output.
vector<int> remaining is used to save numbers remaining to be tried. Pairs from it are combined and separated during recursion, making sure to replace them in their original indexes so all pairs are iterated correctly.
vector<oppair> opseq is used to record the sequence of operations currently being worked on (using the oppair struct which holds operands, operator and result for easy printing) and is used like a stack (in addition to the stack implicit in the recursion). When a better solution than previously is found, its contents are copied to vector<oppair> best_seq.
The solution is correct because dfs search in a finite state space is exhaustive and an optimal solution (in terms of number of moves) is not required.
Because the number of cases is bounded, the numbers used for operations are exactly 6 and decrease with every operation, the number of their combinations is bounded, so the time complexity is technically O(1) :) for a longer list of numbers, I think it would be something like O(n^3) for list length n, but I'm not sure since the dfs is modified to work for pairs but their number is decreasing with each iteration.